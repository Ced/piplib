/******************************************************************************
 *                     PIP : Parametric Integer Programming                   *
 ******************************************************************************
 *                                  maind.h                                   *
 ******************************************************************************
 *                                                                            *
 * Copyright Paul Feautrier, 1988-2005                                        *
 *                                                                            *
 * This library is free software; you can redistribute it and/or modify it    *
 * under the terms of the GNU Lesser General Public License as published by   *
 * the Free Software Foundation; either version 2.1 of the License, or (at    *
 * your option) any later version.                                            *
 *                                                                            *
 * This software is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY *
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License   *
 * for more details.                                                          *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this library; if not, write to the Free Software Foundation,    *
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA         *
 *                                                                            *
 * Written by Paul Feautrier                                                  *
 *                                                                            *
 ******************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <stdlib.h>

#include "pip.h"
#include "version.h"

#ifdef UNIX
#include <sys/times.h>
#endif


/*extern long int cross_product ;*/
extern int PIPLIB_NAME(verbose) ;
extern FILE * PIPLIB_NAME(dump) ;
/*extern int compa_count;*/
extern int PIPLIB_NAME(deepest_cut);


void PIPLIB_NAME(balance)(FILE *foo, FILE *bar)
{
 int level = 0;
 int c;
 while((c = PIPLIB_NAME(dgetc)(foo)) != EOF)
     {
      switch(c)
	  {case '(' : level++; break;
	   case ')' : if(--level == 0) return;
	  }
      putc(c, bar);
     }
}

void PIPLIB_NAME(escape)(FILE *foo, FILE *bar, int level)
{int c;
 while((c = PIPLIB_NAME(dgetc)(foo)) != EOF)
   switch(c)
     {case '(' : level ++; break;
     case ')' : if(--level == 0)
		     { fprintf(bar, "\nSyntax error\n)\n");
		       return;
		     }
     }
}

int main(int argc, char *argv[])
{
 #ifdef UNIX
  struct tms chrono;
  int comptage = 1;
 #endif

 FILE *in, *out;
 PIPLIB_NAME(Tableau) *ineq, *context, *ctxt;
 int nvar, nparm, ni, nc, bigparm;
 int nq; char * g;
 int simple = 0;
 struct PIPLIB_NAME(high_water_mark) hq;
 int c, non_vide;
 int p, q, xq;
 PIPLIB_NAME(piplib_int_t) x;
 piplib_int_init(x);
 #if defined(PIPLIB_ONE_DETERMINANT)
 #else
 PIPLIB_NAME(piplib_int_t) i;
 #endif
 
 in = stdin; out = stdout;
 p = 1;
 if(argc > 1)
 { if(strcmp(argv[1], "-s") == 0)
	 { PIPLIB_NAME(verbose) = -1;
	   p = 2;
	 }
   /* the number of 'v' in the verbose option control the amount of debug
    * information generated by Pip.
    */
   else
	 if(strncmp(argv[1], "-v", 2) == 0)
   { PIPLIB_NAME(verbose) = 1;
     g = argv[1]+2;
     while(*g++ == 'v') PIPLIB_NAME(verbose)++;
	  
     p = 2;
     PIPLIB_NAME(dump) = PIPLIB_NAME(pip_create_dump_file)();
     if (!PIPLIB_NAME(dump))
	PIPLIB_NAME(verbose) = 0;
   }
   if(argc>p && strcmp(argv[p], "-d") == 0)
   { PIPLIB_NAME(deepest_cut) = 1;
     p++;
   }
 }
	
 if(PIPLIB_NAME(verbose) >= 0) fprintf(stderr, "Version "PIPLIB_HEAD"\n");
 if(argc > p)
 { if(strcmp(argv[p], "-z") == 0)
   { simple = 1;
     p++;
   }
   
	 in = fopen(argv[p], "r");
   if(in == NULL)
   { fprintf(stderr, "%s unaccessible\n", argv[p]);
     exit(1);
   }
 }
 p++;
 if(argc>p)
 { out = fopen(argv[p], "w");
   if(out == NULL)
   { fprintf(stderr, "%s unaccessible\n", argv[p]);
     exit(2);
   }
 }
 
 p++;
 PIPLIB_NAME(sol_init)();
 PIPLIB_NAME(tab_init)();
 while((c = PIPLIB_NAME(dgetc)(in)) != EOF)
     {if(c != '(') continue;
      fprintf(out, "(");
      PIPLIB_NAME(balance)(in, out);
      if(PIPLIB_NAME(dscanf)(in, &x) < 0){PIPLIB_NAME(escape)(in, out, 1); continue;}
      else 
        nvar = piplib_int_get_si(x);
      if(PIPLIB_NAME(dscanf)(in, &x) < 0){PIPLIB_NAME(escape)(in, out, 1); continue;}
      else
        nparm = piplib_int_get_si(x);
      if(PIPLIB_NAME(dscanf)(in, &x) < 0){PIPLIB_NAME(escape)(in, out, 1); continue;}
      else 
        ni = piplib_int_get_si(x);
      if(PIPLIB_NAME(dscanf)(in, &x) < 0){PIPLIB_NAME(escape)(in, out, 1); continue;}
      else
        nc = piplib_int_get_si(x);
      if(PIPLIB_NAME(dscanf)(in, &x) < 0){PIPLIB_NAME(escape)(in, out, 1); continue;}
      else 
        bigparm = piplib_int_get_si(x);
      if(PIPLIB_NAME(dscanf)(in, &x) < 0){PIPLIB_NAME(escape)(in, out, 1); continue;}
      else 
        nq = piplib_int_get_si(x);
      
      if(PIPLIB_NAME(verbose) > 0) {fprintf(PIPLIB_NAME(dump), "%d %d %d %d %d %d\n",nvar, nparm, ni, nc,
                               bigparm, nq);
                       fflush(PIPLIB_NAME(dump));
                      }
      /*cross_product = 0;*/
      hq = PIPLIB_NAME(tab_hwm)();
      if(PIPLIB_NAME(verbose) > 0) {fprintf(PIPLIB_NAME(dump), "hwm %p\n", g);
                       fflush(PIPLIB_NAME(dump));
                      }
      ineq = PIPLIB_NAME(tab_get)(in, ni, nvar+nparm+1, nvar);
      if (nq)
	  PIPLIB_NAME(tab_simplify)(ineq, nvar);
      if(ineq == NULL){PIPLIB_NAME(escape)(in, out, 2); continue;}
      context = PIPLIB_NAME(tab_get)(in, nc, nparm+1, 0);
      if (nq)
	  PIPLIB_NAME(tab_simplify)(context, nparm);
      if(context == NULL){PIPLIB_NAME(escape)(in, out, 2); continue;}
      xq = p = PIPLIB_NAME(sol_hwm)();
/* verification de la non-vacuite' du contexte */
      if(nc)
      {ctxt = PIPLIB_NAME(expanser)(context, nparm, nc, nparm+1, nparm, 0, 0);
       PIPLIB_NAME(traiter)(ctxt, NULL, nparm, 0, nc, 0, -1, TRAITER_INT);
       non_vide = PIPLIB_NAME(is_not_Nil)(p);
       PIPLIB_NAME(sol_reset)(p);
      }
      else non_vide = Pip_True;
      if(non_vide) {
       /*compa_count = 0;*/
       PIPLIB_NAME(traiter)(ineq, context, nvar, nparm, ni, nc, bigparm, nq ? TRAITER_INT : 0);
	if (PIPLIB_NAME(verbose) > 0) {
	    fprintf(PIPLIB_NAME(dump), "det: ");
#if defined(PIPLIB_ONE_DETERMINANT)
	    piplib_int_print(PIPLIB_NAME(dump), ineq->determinant);
#else
	    for (i=0; i<ineq->l_determinant; i++) {
		fprintf(PIPLIB_NAME(dump), piplib_int_format, ineq->determinant[i]);
		fprintf(PIPLIB_NAME(dump), " ");
	    }
#endif
	    fprintf(PIPLIB_NAME(dump), "\n");
	}
	fputs(")\n",out);
       if(simple) PIPLIB_NAME(sol_simplify)(xq);
       q = PIPLIB_NAME(sol_hwm)();
       while((xq = PIPLIB_NAME(sol_edit)(out, xq)) != q);
       PIPLIB_NAME(sol_reset)(p);
      }
      else fprintf(out, "void\n");
      PIPLIB_NAME(tab_reset)(hq);
      if(PIPLIB_NAME(verbose) > 0) fflush(PIPLIB_NAME(dump));
      /* add a right parenthesis in order to keep the output in balance */
      fprintf(out, ")\n");
      fflush(out);
      if(PIPLIB_NAME(verbose) >= 0) 
       fprintf(stderr,"cross : (%ld), compa : (%d)\n\r",
               /*cross_product*/0L, /*compa_count*/0);
      #ifdef UNIX
       comptage++;
      #endif
     }
#ifdef UNIX
 times(& chrono);
 fprintf(stderr, "n %d u %d''' s %d'''\r\n",
 comptage, chrono.tms_utime, chrono.tms_stime);
#endif

 piplib_int_clear(x);
 PIPLIB_NAME(pip_close)();
 return 0;
}

